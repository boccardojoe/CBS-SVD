#' Calculate Scaled Norm
#'
#' Calculates the scaled norm of an inputted submatrix (SCNORM).
#' First, calculate the norm of the submatrix and scale by the number of rows and columns in that submatrix.
#'
#' \eqn{L_{\alpha,\beta}(\mathbf{M}^*_{K_u,K_v}) = ||\mathbf{M}^*_{K_u,K_v}||_{\alpha,\beta} = (\sum_{i=1}^{K_u}(\sum_{j=1}^{K_v} |m^*_{ij}|^{\alpha})^{\beta/\alpha})^{1/\beta}}
#'
#' \eqn{SCNORM_{\alpha,\beta,\lambda}(\mathbf{M}^*_{K_u,K_v}) = \frac{L_{\alpha,\beta}(\mathbf{M}^*_{K_u,K_v}) }{(K_uK_v)^{1/\lambda}}}
#'
#' Default settings calculate the submatrix scaled mean (SSM).
#' \eqn{SSM_{\lambda}(\mathbf{M}^{*}_{K_u,K_v}) = \frac{\sum_{i=1}^{K_u}\sum_{j=1}^{K_v}|m^*_{ij}|}{(K_uK_v)^{1/\lambda}}}
#'
#' @param submatrix Inputted submatrix to summarize into one number.
#' @param alpha Tuning parameter controlling the rate of growth of the numerator. Default is 2.
#' @param beta Tuning parameter controlling the rate of growth of the numerator. Default is 2.
#' @param lambda Tuning parameter controlling the rate of growth of the denominator. Default is 2.
#'
#' @return A single numeric value.
#' @export

CalculateScaledNorm <- function(submatrix,alpha=1,beta=1,lambda=2)
{
  submatrix=as.matrix(submatrix)
  LNorm = ((sum(abs(submatrix)^{alpha}))^{beta/alpha})^{1/beta}

  ScaledLNorm = LNorm/((nrow(submatrix)*ncol(submatrix))^(1/lambda))

  return(ScaledLNorm)
}

#' Submatrix Scaled Mean (SSM) Paths Tuning Function (Rank-1)
#'
#' Submatrix Scaled Mean (SSM): \eqn{SSM(\mathbf{M}^{*}_{K_u,K_v}) = \frac{\sum_{i=1}^{K_u}\sum_{j=1}^{K_v}|m^*_{ij}|}{\sqrt{K_uK_v}}}
#'
#' Inputs a matrix and implement optimal cardinality search
#' Starting at cardinality (1,1), increase both until SSM decreases.
#' Then at the last point of increase, fix the cardinality of the rows and increase the column cardinality until SSM decreases.
#' Then fix the cardinality of the columns and increase the row cardinality until SSM decreases.
#'
#' @param Mat Input data matrix
#' @param svdmat Input pre-calculated SVD of the matrix. Default is NULL and the SVD will be calculated if NULL.
#' @param mindiag Where along the diagonal to start searching. Defaults to 1.
#' @param maxrow Maximum number of rows to search over. Default is NULL and if NULL set to number of rows in the matrix \code{Mat}.
#' @param maxcol Maximum number of columns to search over. Default is NULL and if NULL set to number of columns in the matrix \code{Mat}.
#' @param restartrow if TRUE then restart the row to be 1 when searching instead of \code{mindiag}.
#' @param restartcol if TRUE then restart the column to be 1 when searching instead of \code{mindiag}.
#' @param alpha Alpha parameter for the scaled norm function. Controls growth rate of the numerator with \code{alpha}. Default is 1.
#' @param beta Beta parameter for the scaled norm function. Controls growth rate of the numerator with \code{beta}. Default is 1.
#' @param lambda Lambda parameter for the scaled norm function. Controls the growth rate of the denominator. Default is 2.
#' @param doublecheck If TRUE then the algorithm will not terminate at the first SSM decrease unless its greater than the SSM \cocde{checkk} later.
#'
#' @return List of optimal cardinalities:
#' \describe{
#'    \item{Row.SN.Max}{The optimal row cardinality.}
#'    \item{Column.SN.Max}{The optimal column cardinality.}
#'  }
#'  @export


TunebyScaledMeanPaths <- function(Mat,svdmat=NULL,mindiag=NULL,maxrow=NULL,maxcol=NULL,restartrow=TRUE,restartcol=TRUE,alpha=1,beta=1,lambda=2,doubledec=FALSE,checkk=1)
{
  if (is.null(svdmat)) svdmat <- svd(Mat)
  if (is.null(maxrow)) maxrow <- nrow(Mat)
  if (is.null(maxcol)) maxcol <- ncol(Mat)
  if (is.null(mindiag)) mindiag <- 1

  #Search Diagonals
  gc()

  i = mindiag;j = mindiag
  SN.diag <- c()

  repeat{

    print(paste("Starting Path Diagonal search Row=",i,"Column=",j))
    gc()

    M_CBSSVD=CBSSVD_Base(Mat,initialu=svdmat$u[,1],initialv=svdmat$v[,1],ku=i,kv=j)
    M_SUB = Mat[M_CBSSVD$U.selected,M_CBSSVD$V.selected]

    SN.diag[i] =  CalculateScaledNorm(submatrix=M_SUB,alpha=alpha,beta=beta,lambda=lambda)
    if(length(na.omit(SN.diag)) > 1)
    {
      SN.diff = SN.diag[i] - SN.diag[i-1]
      if(SN.diff < 0)
      {
        if(doubledec==FALSE)
        {
          SN.diag.max = i-1
          break
        }
        else if(doubledec==TRUE)
        {
            #Check the next difference to ensure not false positive
              print(paste("Starting Diagonal Check Row=",i+checkk,"Column=",j+checkk))
              M_CBSSVD.p1 = CBSSVD_Base(Mat,initialu=svdmat$u[,1],initialv=svdmat$v[,1],ku=i+checkk,kv=j+checkk)
              M_SUB.p1 = Mat[M_CBSSVD.p1$U.selected,M_CBSSVD.p1$V.selected]
              SN.diag.p1 = CalculateScaledNorm(submatrix=M_SUB.p1,alpha=alpha,beta=beta,lambda=lambda)
              SN.diff.p1 = SN.diag.p1 - SN.diag[i]

              if(SN.diff.p1 < 0)
              {
                SN.diag.max = i-1 #If negative, want the last point of increase
                break
              }
              else
              {
                i=i+1
                j=j+1
              }
            }
      }
      else
      {
        if(i <= maxrow & j <= maxcol)
        {
          i=i+1
          j=j+1
        }
        else
        {
          break
        }
      }
    }
    else
    {
      if(i <= maxrow & j <= maxcol)
      {
        i=i+1
        j=j+1
      }
      else
      {
        break
      }
    }

  }

  SN.row <- c()
  if(restartrow == FALSE){i=SN.diag.max;j=SN.diag.max}
  else if(restartrow == TRUE){i=1;j=SN.diag.max}
  repeat{
    gc()
    print(paste("Starting Row search i=",i,"j=",j))

    M_CBSSVD=CBSSVD_Base(Mat,initialu=svdmat$u[,1],initialv=svdmat$v[,1],ku=i,kv=j)
    M_SUB = Mat[M_CBSSVD$U.selected,M_CBSSVD$V.selected]

    SN.row[i] =CalculateScaledNorm(submatrix=M_SUB,alpha=alpha,beta=beta,lambda=lambda)
    if(length(na.omit(SN.row)) > 1)
    {
      SN.Row.diff = SN.row[i] - SN.row[i-1]
      if(SN.Row.diff < 0)
      {
        if(doubledec==FALSE)
        {
          SN.row.max = i-1
          break
        }
        else if(doubledec==TRUE)
        {
          #Check the next difference to ensure not false positive
            print(paste("Starting Row Check Row=",i+1,"Column=",j))
            M_CBSSVD.Rowp1 = CBSSVD_Base(Mat,initialu=svdmat$u[,1],initialv=svdmat$v[,1],ku=i+checkk,kv=j)
            M_SUB.Rowp1 = Mat[M_CBSSVD.Rowp1$U.selected,M_CBSSVD.Rowp1$V.selected]
            SN.row.p1 = CalculateScaledNorm(submatrix=M_SUB.Rowp1,alpha=alpha,beta=beta,lambda=lambda)
            SN.row.diff.p1 = SN.row.p1 - SN.row[i]

            if(SN.row.diff.p1 < 0)
            {
              SN.row.max = i-1 #If negative, want the last point of increase
              break
            }
            else
            {
              i=i+1
            }
        }
      }
      else
      {
        if(i <= maxrow)
        {
          i=i+1
        }
        else
        {
         break
        }
      }
    }
    else
    {
      if(i <= maxrow)
      {
        i=i+1
      }
      else
      {
        break
      }
    }

  }
  SN.col <- c()
  #Fix columns, search over rows after the diagonal max
  if(restartcol==FALSE){i=SN.diag.max;j=SN.diag.max}
  else if(restartcol==TRUE){i=SN.diag.max;j=1}
  repeat{
    gc()
    print(paste("Starting Column Search Row=",i,"Column=",j))

    M_CBSSVD=CBSSVD_Base(Mat,initialu=svdmat$u[,1],initialv=svdmat$v[,1],ku=i,kv=j)
    M_SUB = Mat[M_CBSSVD$U.selected,M_CBSSVD$V.selected]

    SN.col[j] = CalculateScaledNorm(submatrix=M_SUB,alpha=alpha,beta=beta,lambda=lambda)
    if(length(na.omit(SN.col)) > 1)
    {
      SN.col.diff = SN.col[j] - SN.col[j-1]
      if(SN.col.diff < 0)
      {
        if(doubledec==FALSE)
        {
          SN.col.max = j-1
          break
        }
        else if(doubledec == TRUE)
        {
          #Check the next difference to ensure not false positive
          print(paste("Starting Column Check Row=",i,"Column=",j+1))
          M_CBSSVD.colp1 = CBSSVD_Base(Mat,initialu=svdmat$u[,1],initialv=svdmat$v[,1],ku=i,kv=j+checkk)
          M_SUB.colp1 = Mat[M_CBSSVD.colp1$U.selected,M_CBSSVD.colp1$V.selected]
          SN.col.p1 = CalculateScaledNorm(submatrix=M_SUB.colp1,alpha=alpha,beta=beta,lambda=lambda)
          SN.col.diff.p1 = SN.col.p1 - SN.col[j]

          if(SN.col.diff.p1 < 0)
          {
            SN.col.max = j-1 #If negative, want the last point of increase
            break
          }
          else
          {
            j=j+1
          }
        }
      }
      else
      {
        if(j <= maxcol)
        {
          j=j+1
        }
        else
        {
          break
        }
      }
    }
    else
    {
      if(j <= maxcol)
      {
        j=j+1
      }
      else
      {
        break
      }
    }
  }

  return(list(Row.SN.Max=SN.row.max,
              Column.SN.Max=SN.col.max))
}
